<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#4A90E2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sudoku">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="××©×—×§ ×¡×•×“×•×§×• ××ª×§×“× ×¢× ×¨××•×ª ×§×•×©×™, ×¨××–×™×, ×”×¢×¨×•×ª ×•×¢×•×“">
    
    <title>Sudoku - V7.2</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="./logo.png">
    <link rel="icon" type="image/png" href="./logo.png">
    
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-light: #dee2e6;
            --border-medium: #495057;
            --border-heavy: #212529;
            --cell-fixed: #4A90E2;
            --cell-user: #2d3748;
            --cell-selected: #bfdbfe;
            --cell-highlighted: #dbeafe;
            --cell-conflict: #fee2e2;
            --cell-error: #ef4444;
            --btn-primary: #4A90E2;
            --btn-primary-hover: #3b7bc4;
            --btn-success: #10b981;
            --btn-danger: #ef4444;
            --accent: #8b5cf6;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #404040;
            --text-primary: #e5e5e5;
            --text-secondary: #a0a0a0;
            --border-light: #404040;
            --border-medium: #606060;
            --border-heavy: #808080;
            --cell-fixed: #60a5fa;
            --cell-user: #e5e5e5;
            --cell-selected: #1e3a5f;
            --cell-highlighted: #2d4a6f;
            --cell-conflict: #5a1a1a;
            --cell-error: #ef4444;
            --accent: #a78bfa;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
            padding: 0;
            margin: 0;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            height: 100vh;
            height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
            touch-action: pan-y;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 8px;
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        header {
            text-align: center;
            margin-bottom: 8px;
            position: relative;
        }

        h1 {
            font-size: 22px;
            font-weight: 700;
            color: var(--btn-primary);
            margin-bottom: 4px;
            text-shadow: 0 2px 4px var(--shadow);
        }

        .version {
            font-size: 10px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
            justify-content: center;
        }

        button {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px var(--shadow);
            background: var(--btn-primary);
            color: white;
            display: flex;
            align-items: center;
            gap: 4px;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            user-select: none;
        }

        button:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px var(--shadow);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-success {
            background: var(--btn-success);
        }

        .btn-danger {
            background: var(--btn-danger);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .info-label {
            font-size: 10px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .info-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--btn-primary);
        }

        .game-board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
            flex: 0 0 auto;
            align-items: center;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0;
            background: var(--border-heavy);
            border: 3px solid var(--border-heavy);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px var(--shadow);
            aspect-ratio: 1;
            width: 100%;
            max-width: 500px;
            touch-action: none;
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            font-size: clamp(24px, 8vw, 42px);
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.15s;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .cell:nth-child(9n+4), 
        .cell:nth-child(9n+7) {
            border-right: 3px solid var(--border-heavy) !important;
        }
        
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 3px solid var(--border-heavy) !important;
        }

        .cell.fixed {
            color: var(--cell-fixed);
            font-weight: 700;
        }

        .cell.user {
            color: var(--cell-user);
        }

        .cell.selected {
            background: var(--cell-selected) !important;
            border: 2px solid var(--btn-primary);
            z-index: 10;
        }

        .cell.highlighted {
            background: var(--cell-highlighted);
            box-shadow: inset 0 0 0 2px var(--btn-primary);
        }

        .cell.conflict {
            background: var(--cell-conflict);
            box-shadow: inset 0 0 0 3px var(--cell-error);
            animation: conflictPulse 0.5s ease-in-out;
        }

        @keyframes conflictPulse {
            0%, 100% { box-shadow: inset 0 0 0 3px var(--cell-error); }
            50% { box-shadow: inset 0 0 0 4px var(--cell-error); }
        }

        .cell.wrong {
            color: var(--cell-error) !important;
            background: var(--cell-conflict);
            font-weight: 900 !important;
            animation: wrongShake 0.3s ease-in-out;
        }

        @keyframes wrongShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        .cell.victory-pulse {
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .notes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            padding: 2px;
            gap: 1px;
        }

        .notes span {
            font-size: clamp(8px, 1.5vw, 10px);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
        }

        .number-pad {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin-bottom: 8px;
            padding: 0 4px;
        }

        .number-btn {
            aspect-ratio: 1.2;
            font-size: 32px;
            font-weight: 700;
            position: relative;
            padding: 12px 8px;
        }

        .count {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 9px;
            background: var(--btn-success);
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-primary);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--btn-primary);
            text-align: center;
        }

        .difficulty-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 16px;
        }

        .difficulty-btn {
            padding: 16px;
            font-size: 16px;
            border-radius: 12px;
            width: 100%;
            justify-content: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--btn-primary);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .victory-content {
            text-align: center;
        }

        .victory-icon {
            font-size: 64px;
            margin-bottom: 16px;
            animation: bounce 1s ease-in-out;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .victory-message {
            font-size: 20px;
            font-weight: 700;
            color: var(--btn-success);
            margin-bottom: 20px;
        }

        .victory-stats {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .victory-stats p {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .game-board.victory-animation .cell {
            animation: victoryPulse 1.5s ease-in-out;
        }

        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); background: var(--bg-primary); }
            50% { transform: scale(1.05); background: var(--cell-highlighted); }
        }

        /* Install prompt */
        .install-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--btn-primary);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 2000;
            animation: slideUp 0.3s ease-out;
        }

        .install-prompt.show {
            display: flex;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(100%);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .install-prompt button {
            background: white;
            color: var(--btn-primary);
            padding: 6px 16px;
            font-size: 14px;
        }

        .close-btn {
            background: transparent;
            color: white;
            padding: 4px 8px;
            font-size: 20px;
            box-shadow: none;
        }

        /* Loading indicator */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        /* Responsive adjustments for very small screens */
        @media (max-width: 360px) {
            .container {
                padding: 4px;
            }
            
            h1 {
                font-size: 18px;
            }
            
            button {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            .game-board {
                max-width: 100%;
            }
        }

        /* Safe area insets for notched devices */
        @supports (padding: max(0px)) {
            body {
                padding-left: max(0px, env(safe-area-inset-left));
                padding-right: max(0px, env(safe-area-inset-right));
                padding-top: max(0px, env(safe-area-inset-top));
                padding-bottom: max(0px, env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Sudoku </h1>
            <div class="version"> V7.2 </div>
        </header>

        <div class="controls">
            <button id="newGameBtn" class="btn-primary">ğŸ® ××©×—×§ ×—×“×©</button>
            <button id="hintBtn" class="btn-success">ğŸ’¡</button>
            <button id="noteBtn" class="btn-secondary">ğŸ“ </button>
            <button id="undoBtn" class="btn-secondary">â†¶ </button>
            <button id="redoBtn" class="btn-secondary">â†· </button>
            <button id="statsBtn" class="btn-secondary">ğŸ“Š </button>
            <button id="themeToggle" class="btn-secondary">ğŸŒ™</button>
        </div>

        <div class="info-bar">
            <div class="info-item">
                <div class="info-label">×–××Ÿ</div>
                <div class="info-value" id="timer">00:00</div>
            </div>
            <div class="info-item">
                <div class="info-label">×“×¨×’×ª ×§×•×©×™</div>
                <div class="info-value" id="difficulty">×‘×™× ×•× ×™</div>
            </div>
            <div class="info-item">
                <div class="info-label">×¨××–×™×</div>
                <div class="info-value" id="hintsCount">3</div>
            </div>
        </div>

        <div class="game-board-container">
            <div id="gameBoard" class="game-board"></div>
        </div>

        <div id="numberPad" class="number-pad"></div>
    </div>

    <!-- Install Prompt -->
    <div id="installPrompt" class="install-prompt">
        <span>ğŸ“± ×”×ª×§×Ÿ ××ª ×”××©×—×§ ×œ××›×©×™×¨ ×©×œ×š</span>
        <button id="installBtn">×”×ª×§×Ÿ</button>
        <button id="closeInstall" class="close-btn">âœ•</button>
    </div>

    <!-- Difficulty Modal -->
    <div id="difficultyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">×‘×—×¨ ×“×¨×’×ª ×§×•×©×™</div>
            <div class="difficulty-options">
                <button class="difficulty-btn btn-success" onclick="uiController.startNewGame('easy')">
                    ğŸ˜Š ×§×œ - ×œ××ª×—×™×œ×™×
                </button>
                <button class="difficulty-btn btn-primary" onclick="uiController.startNewGame('medium')">
                    ğŸ¯ ×‘×™× ×•× ×™ - ××ª×’×¨ ×¡×‘×™×¨
                </button>
                <button class="difficulty-btn btn-danger" onclick="uiController.startNewGame('hard')">
                    ğŸ”¥ ×§×©×” - ××•××—×™× ×‘×œ×‘×“
                </button>
            </div>
            <div id="resumeContainer" style="display: none; margin-top: 12px;">
                <button class="difficulty-btn btn-secondary" onclick="uiController.difficultyModal.classList.remove('active')">
                    â–¶ï¸ ×”××©×š ××©×—×§ ×§×•×“×
                </button>
            </div>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="statsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">ğŸ“Š ×”×¡×˜×˜×™×¡×˜×™×§×” ×©×œ×™</div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalWins">0</div>
                    <div class="stat-label">× ×™×¦×—×•× ×•×ª</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="gamesPlayed">0</div>
                    <div class="stat-label">××©×—×§×™×</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="bestTime">--:--</div>
                    <div class="stat-label">×©×™× ×–××Ÿ</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgHints">0</div>
                    <div class="stat-label">×××•×¦×¢ ×¨××–×™×</div>
                </div>
            </div>
            <button class="difficulty-btn btn-secondary" onclick="document.getElementById('statsModal').classList.remove('active')">
                ×¡×’×•×¨
            </button>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victoryModal" class="modal">
        <div class="modal-content">
            <div class="victory-content">
                <div class="victory-icon">ğŸ†</div>
                <div class="victory-message">×›×œ ×”×›×‘×•×“! × ×™×¦×—×ª!</div>
                <div class="victory-stats">
                    <h3 style="text-align: center; margin-bottom: 15px; color: #4A90E2;">ğŸ“Š ×¡×™×›×•× ×”××©×—×§</h3>
                    <div style="display: grid; gap: 10px;">
                        <p><strong>â±ï¸ ×–××Ÿ ××©×—×§:</strong> <span id="victoryTime">00:00</span></p>
                        <p><strong>ğŸ’¡ ×¨××–×™× ×©× ×•×¦×œ×•:</strong> <span id="victoryHints">0</span> ××ª×•×š 3</p>
                        <p><strong>ğŸ¯ ×“×¨×’×ª ×§×•×©×™:</strong> <span id="victoryDifficulty">×‘×™× ×•× ×™</span></p>
                        <p><strong>ğŸ“ˆ ×“×™×¨×•×’:</strong> <span id="victoryRating">â­â­â­</span></p>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="difficulty-btn btn-primary" style="flex: 1;" onclick="uiController.showDifficultyModal(); document.getElementById('victoryModal').classList.remove('active')">
                        ğŸ® ××©×—×§ ×—×“×©
                    </button>
                    <button class="difficulty-btn btn-secondary" style="flex: 1;" onclick="uiController.showStats(); document.getElementById('victoryModal').classList.remove('active')">
                        ğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×”
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============= SUDOKU ENGINE =============
        class SudokuEngine {
            constructor() {
                this.board = Array(81).fill(0);
                this.solution = Array(81).fill(0);
                this.fixed = Array(81).fill(false);
                this.notes = Array(81).fill(null).map(() => new Set());
            }

            generate(difficulty = 'medium') {
                this.board = Array(81).fill(0);
                this.solution = Array(81).fill(0);
                this.fixed = Array(81).fill(false);
                this.notes = Array(81).fill(null).map(() => new Set());

                this.fillDiagonal();
                this.solve(0);
                this.solution = [...this.board];

                const cellsToRemove = {
                    easy: 35,
                    medium: 45,
                    hard: 55
                }[difficulty] || 45;

                this.removeNumbers(cellsToRemove);
                
                this.board.forEach((val, idx) => {
                    if (val !== 0) this.fixed[idx] = true;
                });
            }

            fillDiagonal() {
                for (let box = 0; box < 9; box += 3) {
                    this.fillBox(box, box);
                }
            }

            fillBox(row, col) {
                const nums = this.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                let idx = 0;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        this.board[(row + i) * 9 + (col + j)] = nums[idx++];
                    }
                }
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            solve(index) {
                if (index === 81) return true;
                if (this.board[index] !== 0) return this.solve(index + 1);

                const nums = this.shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                for (let num of nums) {
                    if (this.isValid(index, num)) {
                        this.board[index] = num;
                        if (this.solve(index + 1)) return true;
                        this.board[index] = 0;
                    }
                }
                return false;
            }

            isValid(index, num) {
                const row = Math.floor(index / 9);
                const col = index % 9;

                for (let i = 0; i < 9; i++) {
                    if (this.board[row * 9 + i] === num && row * 9 + i !== index) return false;
                    if (this.board[i * 9 + col] === num && i * 9 + col !== index) return false;
                }

                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const boxIndex = (boxRow + i) * 9 + (boxCol + j);
                        if (this.board[boxIndex] === num && boxIndex !== index) return false;
                    }
                }

                return true;
            }

            removeNumbers(count) {
                const positions = this.shuffle([...Array(81).keys()]);
                let removed = 0;

                for (let pos of positions) {
                    if (removed >= count) break;
                    const backup = this.board[pos];
                    this.board[pos] = 0;
                    
                    const tempBoard = [...this.board];
                    if (this.hasUniqueSolution(tempBoard)) {
                        removed++;
                    } else {
                        this.board[pos] = backup;
                    }
                }
            }

            hasUniqueSolution(board) {
                let solutions = 0;
                const solve = (index) => {
                    if (solutions > 1) return;
                    if (index === 81) {
                        solutions++;
                        return;
                    }
                    if (board[index] !== 0) {
                        solve(index + 1);
                        return;
                    }

                    for (let num = 1; num <= 9; num++) {
                        if (this.isValidForBoard(board, index, num)) {
                            board[index] = num;
                            solve(index + 1);
                            board[index] = 0;
                        }
                    }
                };

                solve(0);
                return solutions === 1;
            }

            isValidForBoard(board, index, num) {
                const row = Math.floor(index / 9);
                const col = index % 9;

                for (let i = 0; i < 9; i++) {
                    if (board[row * 9 + i] === num) return false;
                    if (board[i * 9 + col] === num) return false;
                }

                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (board[(boxRow + i) * 9 + (boxCol + j)] === num) return false;
                    }
                }

                return true;
            }

            isSolved() {
                return this.board.every((val, idx) => val === this.solution[idx]);
            }

            setCell(index, value) {
                if (!this.fixed[index]) {
                    this.board[index] = value;
                    if (value !== 0) {
                        this.notes[index].clear();
                    }
                }
            }

            toggleNote(index, number) {
                if (!this.fixed[index] && this.board[index] === 0) {
                    if (this.notes[index].has(number)) {
                        this.notes[index].delete(number);
                    } else {
                        this.notes[index].add(number);
                    }
                }
            }
        }

        // ============= GAME STATE =============
        class GameState {
            constructor() {
                this.engine = new SudokuEngine();
                this.selectedCell = null;
                this.noteMode = false;
                this.difficulty = 'medium';
                this.timer = 0;
                this.timerInterval = null;
                this.hints = 3;
                this.history = [];
                this.historyIndex = -1;
                this.stats = this.loadStats();
                
                this.loadGame();
            }

            newGame(difficulty = 'medium') {
                console.log(`[Debug] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
                console.log(`[Debug] Starting new game - Difficulty: ${difficulty.toUpperCase()}`);
                console.log(`[Debug] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
                
                this.difficulty = difficulty;
                this.timer = 0;
                this.hints = 3;
                this.selectedCell = null;
                this.noteMode = false;
                this.history = [];
                this.historyIndex = -1;

                this.engine.generate(difficulty);
                console.log('[Debug] Puzzle generated successfully');
                console.log('[Debug] Solution:', this.engine.solution);
                
                this.saveState();
                this.startTimer();
            }

            startTimer() {
                if (this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    this.saveGame();
                }, 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            selectCell(index) {
                this.selectedCell = index;
            }

            inputNumber(number) {
                if (this.selectedCell === null || this.engine.fixed[this.selectedCell]) {
                    console.log('[Debug] Cannot input: Cell is null or fixed');
                    return;
                }

                this.saveState();

                if (this.noteMode) {
                    this.engine.toggleNote(this.selectedCell, number);
                    console.log(`[Debug] Toggled note ${number} at cell ${this.selectedCell}`);
                } else {
                    const oldValue = this.engine.board[this.selectedCell];
                    this.engine.setCell(this.selectedCell, number);
                    const correctValue = this.engine.solution[this.selectedCell];
                    
                    console.log(`[Debug] Input ${number} at cell ${this.selectedCell} (row: ${Math.floor(this.selectedCell/9)}, col: ${this.selectedCell%9})`);
                    console.log(`[Debug] Correct value: ${correctValue}, Input: ${number}, Status: ${number === correctValue ? 'âœ“ CORRECT' : 'âœ— WRONG'}`);
                    
                    if (oldValue !== number) {
                        console.log(`[Debug] Changed from ${oldValue} to ${number}`);
                    }
                }

                this.saveGame();

                if (this.engine.isSolved()) {
                    console.log('[Debug] â˜…â˜…â˜… PUZZLE SOLVED! â˜…â˜…â˜…');
                    this.onWin();
                }
            }

            clearCell() {
                if (this.selectedCell === null || this.engine.fixed[this.selectedCell]) return;
                
                this.saveState();
                this.engine.setCell(this.selectedCell, 0);
                this.engine.notes[this.selectedCell].clear();
                this.saveGame();
            }

            useHint() {
                if (this.hints <= 0 || this.selectedCell === null || this.engine.fixed[this.selectedCell]) {
                    console.log('[Debug] Cannot use hint - hints:', this.hints, 'selected:', this.selectedCell);
                    return;
                }

                this.saveState();
                this.hints--;
                const correctValue = this.engine.solution[this.selectedCell];
                this.engine.setCell(this.selectedCell, correctValue);
                this.engine.notes[this.selectedCell].clear();
                
                console.log(`[Debug] ğŸ’¡ Hint used! Cell ${this.selectedCell} set to ${correctValue}`);
                console.log(`[Debug] Hints remaining: ${this.hints}`);
                
                this.saveGame();

                if (this.engine.isSolved()) {
                    console.log('[Debug] Puzzle solved after hint!');
                    this.onWin();
                }
            }

            toggleNoteMode() {
                this.noteMode = !this.noteMode;
            }

            saveState() {
                this.history = this.history.slice(0, this.historyIndex + 1);
                
                this.history.push({
                    board: [...this.engine.board],
                    notes: this.engine.notes.map(set => new Set(set)),
                    hints: this.hints
                });
                
                this.historyIndex++;

                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    const state = this.history[this.historyIndex];
                    this.engine.board = [...state.board];
                    this.engine.notes = state.notes.map(set => new Set(set));
                    this.hints = state.hints;
                    this.saveGame();
                    console.log(`[Debug] Undo performed - History index: ${this.historyIndex}`);
                    return true;
                }
                console.log('[Debug] Cannot undo - at beginning of history');
                return false;
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    const state = this.history[this.historyIndex];
                    this.engine.board = [...state.board];
                    this.engine.notes = state.notes.map(set => new Set(set));
                    this.hints = state.hints;
                    this.saveGame();
                    console.log(`[Debug] Redo performed - History index: ${this.historyIndex}`);
                    return true;
                }
                console.log('[Debug] Cannot redo - at end of history');
                return false;
            }

            saveGame() {
                const gameData = {
                    board: this.engine.board,
                    solution: this.engine.solution,
                    fixed: this.engine.fixed,
                    notes: this.engine.notes.map(set => Array.from(set)),
                    difficulty: this.difficulty,
                    timer: this.timer,
                    hints: this.hints,
                    history: this.history.map(state => ({
                        board: state.board,
                        notes: state.notes.map(set => Array.from(set)),
                        hints: state.hints
                    })),
                    historyIndex: this.historyIndex
                };
                
                localStorage.setItem('sudoku_save', JSON.stringify(gameData));
                console.log('[Debug] Game saved to localStorage');
            }

            loadGame() {
                const saved = localStorage.getItem('sudoku_save');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.engine.board = data.board;
                        this.engine.solution = data.solution;
                        this.engine.fixed = data.fixed;
                        this.engine.notes = data.notes.map(arr => new Set(arr));
                        this.difficulty = data.difficulty;
                        this.timer = data.timer;
                        this.hints = data.hints;
                        this.history = data.history.map(state => ({
                            board: state.board,
                            notes: state.notes.map(arr => new Set(arr)),
                            hints: state.hints
                        }));
                        this.historyIndex = data.historyIndex;
                        this.startTimer();
                        console.log('[Debug] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                        console.log('[Debug] Game loaded from localStorage');
                        console.log('[Debug] Difficulty:', this.difficulty);
                        console.log('[Debug] Timer:', this.formatTime(this.timer));
                        console.log('[Debug] Hints:', this.hints);
                        console.log('[Debug] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                        return true;
                    } catch (e) {
                        console.error('[Debug] Failed to load game:', e);
                    }
                }
                console.log('[Debug] No saved game found');
                return false;
            }

            hasSavedGame() {
                return localStorage.getItem('sudoku_save') !== null;
            }

            onWin() {
                this.stopTimer();
                
                this.stats.totalWins++;
                this.stats.gamesPlayed++;
                this.stats.totalHints += (3 - this.hints);
                
                if (!this.stats.bestTime || this.timer < this.stats.bestTime) {
                    this.stats.bestTime = this.timer;
                }
                
                this.saveStats();
                localStorage.removeItem('sudoku_save');
            }

            loadStats() {
                const saved = localStorage.getItem('sudoku_stats');
                if (saved) {
                    return JSON.parse(saved);
                }
                return {
                    totalWins: 0,
                    gamesPlayed: 0,
                    bestTime: null,
                    totalHints: 0
                };
            }

            saveStats() {
                localStorage.setItem('sudoku_stats', JSON.stringify(this.stats));
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // ============= UI CONTROLLER =============
        class UIController {
            constructor(gameState) {
                this.game = gameState;
                this.initializeElements();
                this.initializeBoard();
                this.initializeNumberPad();
                this.attachEventListeners();
                this.initializeTheme();
                this.updateUI();
            }

            initializeElements() {
                this.gameBoard = document.getElementById('gameBoard');
                this.numberPad = document.getElementById('numberPad');
                this.timer = document.getElementById('timer');
                this.difficultyDisplay = document.getElementById('difficulty');
                this.hintsCount = document.getElementById('hintsCount');
                
                this.newGameBtn = document.getElementById('newGameBtn');
                this.hintBtn = document.getElementById('hintBtn');
                this.noteBtn = document.getElementById('noteBtn');
                this.undoBtn = document.getElementById('undoBtn');
                this.redoBtn = document.getElementById('redoBtn');
                this.statsBtn = document.getElementById('statsBtn');
                this.themeToggle = document.getElementById('themeToggle');
                
                this.difficultyModal = document.getElementById('difficultyModal');
                this.statsModal = document.getElementById('statsModal');
                this.victoryModal = document.getElementById('victoryModal');
            }

            initializeBoard() {
                for (let i = 0; i < 81; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    this.gameBoard.appendChild(cell);
                }
            }

            initializeNumberPad() {
                for (let i = 1; i <= 9; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'number-btn';
                    btn.dataset.number = i;
                    btn.innerHTML = `<span class="count" data-number="${i}">9</span>${i}`;
                    this.numberPad.appendChild(btn);
                }

                const clearBtn = document.createElement('button');
                clearBtn.className = 'number-btn btn-danger';
                clearBtn.innerHTML = 'ğŸ—‘ï¸';
                clearBtn.addEventListener('click', () => this.game.clearCell());
                this.numberPad.appendChild(clearBtn);
            }

            attachEventListeners() {
                this.gameBoard.addEventListener('click', (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell) {
                        const index = parseInt(cell.dataset.index);
                        this.game.selectCell(index);
                        this.updateUI();
                    }
                });

                this.numberPad.addEventListener('click', (e) => {
                    const btn = e.target.closest('.number-btn');
                    if (btn && btn.dataset.number) {
                        this.game.inputNumber(parseInt(btn.dataset.number));
                        this.updateUI();
                    }
                });

                this.newGameBtn.addEventListener('click', () => this.showDifficultyModal());
                this.hintBtn.addEventListener('click', () => {
                    this.game.useHint();
                    this.updateUI();
                });
                this.noteBtn.addEventListener('click', () => {
                    this.game.toggleNoteMode();
                    this.updateUI();
                });
                this.undoBtn.addEventListener('click', () => this.undo());
                this.redoBtn.addEventListener('click', () => this.redo());
                this.statsBtn.addEventListener('click', () => this.showStats());
                this.themeToggle.addEventListener('click', () => this.toggleTheme());

                // Keyboard support
                document.addEventListener('keydown', (e) => {
                    if (this.game.selectedCell === null) return;

                    if (e.key >= '1' && e.key <= '9') {
                        this.game.inputNumber(parseInt(e.key));
                        this.updateUI();
                    } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
                        this.game.clearCell();
                        this.updateUI();
                    } else if (e.key === 'n' || e.key === 'N') {
                        this.game.toggleNoteMode();
                        this.updateUI();
                    }
                });
            }

            initializeTheme() {
                const saved = localStorage.getItem('sudoku_theme');
                if (saved) {
                    document.documentElement.setAttribute('data-theme', saved);
                    this.themeToggle.textContent = saved === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
                }
            }

            undo() {
                if (this.game.undo()) {
                    this.updateUI();
                }
            }

            redo() {
                if (this.game.redo()) {
                    this.updateUI();
                }
            }

            showDifficultyModal() {
                const resumeContainer = document.getElementById('resumeContainer');
                if (this.game.hasSavedGame()) {
                    resumeContainer.style.display = 'block';
                } else {
                    resumeContainer.style.display = 'none';
                }
                this.difficultyModal.classList.add('active');
            }

            startNewGame(difficulty) {
                this.difficultyModal.classList.remove('active');
                this.game.newGame(difficulty);
                this.updateUI();
            }

            showStats() {
                const stats = this.game.stats;
                document.getElementById('totalWins').textContent = stats.totalWins;
                document.getElementById('gamesPlayed').textContent = stats.gamesPlayed;
                document.getElementById('bestTime').textContent = stats.bestTime 
                    ? this.game.formatTime(stats.bestTime) 
                    : '--:--';
                
                const avgHints = stats.totalWins > 0 
                    ? (stats.totalHints / stats.totalWins).toFixed(1)
                    : '0';
                document.getElementById('avgHints').textContent = avgHints;

                this.statsModal.classList.add('active');
            }

            toggleTheme() {
                const current = document.documentElement.getAttribute('data-theme');
                const newTheme = current === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('sudoku_theme', newTheme);
                this.themeToggle.textContent = newTheme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
            }

            updateUI() {
                this.updateBoard();
                this.updateNumberPad();
                this.updateControls();
                this.updateInfo();
            }

            updateBoard() {
                const cells = this.gameBoard.querySelectorAll('.cell');
                
                // Get conflicts for selected cell
                const conflicts = this.game.selectedCell !== null && this.game.engine.board[this.game.selectedCell] !== 0
                    ? this.getConflicts(this.game.selectedCell)
                    : [];
                
                // Get all cells with same number as selected cell
                const selectedNumber = this.game.selectedCell !== null 
                    ? this.game.engine.board[this.game.selectedCell]
                    : 0;
                
                cells.forEach((cell, index) => {
                    cell.className = 'cell';
                    cell.innerHTML = '';

                    if (this.game.engine.fixed[index]) {
                        cell.classList.add('fixed');
                    } else {
                        cell.classList.add('user');
                        
                        // Mark wrong answers (user input that doesn't match solution)
                        if (this.game.engine.board[index] !== 0 && 
                            this.game.engine.board[index] !== this.game.engine.solution[index]) {
                            cell.classList.add('wrong');
                        }
                    }
              
                    if (index === this.game.selectedCell) {
                        cell.classList.add('selected');
                    }

                    // Highlight conflicts (cells that conflict with selected cell)
                    if (conflicts.includes(index)) {
                        cell.classList.add('conflict');
                    }

                    // Highlight cells with same number as selected cell
                    if (selectedNumber !== 0 && this.game.engine.board[index] === selectedNumber) {
                        cell.classList.add('highlighted');
                    }

                    if (this.game.engine.board[index] !== 0) {
                        cell.textContent = this.game.engine.board[index];
                    } else if (this.game.engine.notes[index].size > 0) {
                        const notesDiv = document.createElement('div');
                        notesDiv.className = 'notes';
                        
                        for (let i = 1; i <= 9; i++) {
                            const noteSpan = document.createElement('span');
                            noteSpan.textContent = this.game.engine.notes[index].has(i) ? i : '';
                            notesDiv.appendChild(noteSpan);
                        }
                        
                        cell.appendChild(notesDiv);
                    }
                });
            }

            getConflicts(index) {
                const conflicts = [];
                const value = this.game.engine.board[index];
                
                if (value === 0) return conflicts;
                
                const row = Math.floor(index / 9);
                const col = index % 9;
                
                // Check row conflicts
                for (let i = 0; i < 9; i++) {
                    const cellIndex = row * 9 + i;
                    if (cellIndex !== index && this.game.engine.board[cellIndex] === value) {
                        conflicts.push(cellIndex);
                    }
                }
                
                // Check column conflicts
                for (let i = 0; i < 9; i++) {
                    const cellIndex = i * 9 + col;
                    if (cellIndex !== index && this.game.engine.board[cellIndex] === value) {
                        conflicts.push(cellIndex);
                    }
                }
                
                // Check 3x3 box conflicts
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const cellIndex = (boxRow + i) * 9 + (boxCol + j);
                        if (cellIndex !== index && this.game.engine.board[cellIndex] === value) {
                            if (!conflicts.includes(cellIndex)) {
                                conflicts.push(cellIndex);
                            }
                        }
                    }
                }
                
                return conflicts;
            }

            updateNumberPad() {
                const counts = Array(10).fill(0);
                this.game.engine.board.forEach(num => {
                    if (num !== 0) counts[num]++;
                });

                for (let i = 1; i <= 9; i++) {
                    const countSpan = document.querySelector(`.count[data-number="${i}"]`);
                    if (countSpan) {
                        const remaining = 9 - counts[i];
                        countSpan.textContent = remaining;
                        
                        // Disable button when all 9 placements are used
                        if (remaining === 0) {
                            countSpan.parentElement.disabled = true;
                            countSpan.parentElement.style.opacity = '0.3';
                        } else {
                            countSpan.parentElement.disabled = false;
                            countSpan.parentElement.style.opacity = '1';
                        }
                    }
                }
            }

            updateControls() {
                if (this.game.noteMode) {
                    this.noteBtn.classList.add('btn-success');
                    this.noteBtn.classList.remove('btn-secondary');
                } else {
                    this.noteBtn.classList.add('btn-secondary');
                    this.noteBtn.classList.remove('btn-success');
                }

                this.undoBtn.disabled = this.game.historyIndex <= 0;
                this.redoBtn.disabled = this.game.historyIndex >= this.game.history.length - 1;

                this.hintBtn.disabled = this.game.hints <= 0 || this.game.selectedCell === null || 
                                       this.game.engine.fixed[this.game.selectedCell];
            }

            updateInfo() {
                this.timer.textContent = this.game.formatTime(this.game.timer);
                
                const difficultyNames = {
                    easy: '×§×œ',
                    medium: '×‘×™× ×•× ×™',
                    hard: '×§×©×”'
                };
                this.difficultyDisplay.textContent = difficultyNames[this.game.difficulty] || '×‘×™× ×•× ×™';
                this.hintsCount.textContent = this.game.hints;
            }

            showVictory() {
                const usedHints = 3 - this.game.hints;
                const timeInSeconds = this.game.timer;
                
                // Calculate rating (1-5 stars)
                let rating = 5;
                if (usedHints > 0) rating -= usedHints;
                if (timeInSeconds > 600) rating -= 1; // More than 10 minutes
                if (timeInSeconds > 1200) rating -= 1; // More than 20 minutes
                rating = Math.max(1, Math.min(5, rating));
                
                const stars = 'â­'.repeat(rating) + 'â˜†'.repeat(5 - rating);
                
                const difficultyNames = {
                    easy: '×§×œ ğŸ˜Š',
                    medium: '×‘×™× ×•× ×™ ğŸ¯',
                    hard: '×§×©×” ğŸ”¥'
                };
                
                document.getElementById('victoryTime').textContent = this.game.formatTime(timeInSeconds);
                document.getElementById('victoryHints').textContent = usedHints;
                document.getElementById('victoryDifficulty').textContent = difficultyNames[this.game.difficulty] || '×‘×™× ×•× ×™';
                document.getElementById('victoryRating').textContent = stars;
                
                console.log('[Debug] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('[Debug] ğŸ‰ VICTORY! Game completed successfully!');
                console.log('[Debug] Time:', this.game.formatTime(timeInSeconds));
                console.log('[Debug] Hints used:', usedHints);
                console.log('[Debug] Difficulty:', this.game.difficulty);
                console.log('[Debug] Rating:', rating, 'stars');
                console.log('[Debug] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                this.victoryModal.classList.add('active');
                this.gameBoard.classList.add('victory-animation');
                
                setTimeout(() => {
                    this.gameBoard.classList.remove('victory-animation');
                }, 1500);
            }
        }

        // ============= PWA INSTALL PROMPT =============
        let deferredPrompt;
        const installPrompt = document.getElementById('installPrompt');
        const installBtn = document.getElementById('installBtn');
        const closeInstall = document.getElementById('closeInstall');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install prompt after 10 seconds
            setTimeout(() => {
                if (!window.matchMedia('(display-mode: standalone)').matches) {
                    installPrompt.classList.add('show');
                }
            }, 10000);
        });

        installBtn.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response: ${outcome}`);
                deferredPrompt = null;
                installPrompt.classList.remove('show');
            }
        });

        closeInstall.addEventListener('click', () => {
            installPrompt.classList.remove('show');
        });

        // Hide install prompt if already installed
        window.addEventListener('appinstalled', () => {
            console.log('PWA installed successfully');
            installPrompt.classList.remove('show');
        });

        // ============= SERVICE WORKER REGISTRATION =============
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => {
                        console.log('Service Worker registered successfully');
                        
                        // Check for updates
                        reg.addEventListener('updatefound', () => {
                            const newWorker = reg.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('New version available! Please refresh.');
                                }
                            });
                        });
                    })
                    .catch(err => console.log('Service Worker registration failed:', err));
            });
        }

        // ============= INITIALIZE APP =============
        let gameState, uiController;

        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ğŸ® Sudoku Master Ultimate v7.2');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

        window.addEventListener('DOMContentLoaded', () => {
            console.log('[Debug] DOM loaded, initializing game...');
            
            gameState = new GameState();
            uiController = new UIController(gameState);

            const originalOnWin = gameState.onWin.bind(gameState);
            gameState.onWin = function() {
                originalOnWin();
                uiController.showVictory();
            };

            if (gameState.hasSavedGame()) {
                console.log('[Debug] Found saved game, resuming...');
            } else {
                console.log('[Debug] No saved game, showing difficulty modal...');
                uiController.showDifficultyModal();
            }
            
            console.log('[Debug] Game initialized successfully');
        });

        // Prevent accidental page close
        window.addEventListener('beforeunload', (e) => {
            if (gameState && gameState.hasSavedGame() && gameState.timer > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Prevent pull-to-refresh on mobile
        document.body.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // Handle iOS safe areas
        if (navigator.standalone || window.matchMedia('(display-mode: standalone)').matches) {
            document.documentElement.style.setProperty('--safe-area-top', 'env(safe-area-inset-top)');
        }
    </script>
</body>
</html>
